
# NVDLA的浮点数据通路

（本文是王逵看NVDLA代码的笔记，不保证正确）

NV_NVDLA_CMAC_CORE_mac这个模块，支持64个activations和64个weights进行点乘，也就是说，64对数据逐对相乘，得到的64个乘积后，经过一个加法树，加在一起得到一个总和。数据类型支持FP16和INT16。此外，它还能做子字并行，为INT8同时做两组64表项的向量点乘；加法树还支持winograd的post-addtion。这两项额外功能先不谈，本文介绍一下如何在一个数据通路内同时支持FP16和INT16。

INT16的点乘的处理方式是众所周知的：两个INT16数据相乘得到INT32，然后用加法树进行累加，累加过程中比特数逐渐增加，最后得到更宽的整数sum。NVDLA比较有特色的是如何复用INT16的数据通路来支持FP16。

FP16有1位符号、5位指数e和10位尾数m，把尾数前面隐藏的1算上，有效数字是11位。先把FP16转成1位符号、3位指数E和14位有效数字M构成的内部表示，转换方式是：E=e[5:2], M={5'b00001,m}<<e[1:0]。注意此时E加一或减一相当于M左移或右移四比特。

在计算乘法时，指数部分相加，有效数字部分相乘。15位的M进行相乘，可以复用INT16的乘法器（Radix-4的Booth乘法器）。两个3bit的指数相加，结果是4bit。64个乘积，先统一做一下有效数字的对齐，方法是：64个乘积的指数部分先选出一个最大的来，即64个4bit数选最大，这个计算用DesignWare搞定；然后所有其它乘积都要把有效数字部分右移，指数部分比最大的小1，就要右移4位，小2则右移8位，以此类推。注意这里的右移就是纯粹的右移，不是带sticky的移位。

有效数字部分对齐之后，就可以进加法树了。加法树的设计，同输入的数据是FP16还是INT16无关。

关于Radix-4的Booth乘法器，值得再说一句。INT16相乘是有符号数，但浮点的乘法是对无符号数进行的，而且carry-save-adder-tree（CSA-tree）要求输入都是有符号数。为了让迁就CSA-tree，NV_NVDLA_CMAC_CORE_MAC_booth中专门为浮点负数把code取反，另外输出了res_tag位，res_tag有8个bit，表示8个位置上是否需要加上-1。

代码看到这里，我有一个疑问。上述很多麻烦的根源，是因为浮点数的有效位是“符号位+无符号数”的表示形式，而不是直接用二进制补码；那么我们能不能在CMAC里采用一种FP16的自定义表示？这种表示中，有5位的指数和11位的尾数，尾数采用二进制补码。在写入CBUF的时候，把这种转换做掉，CMAC就能爽很多。CBUF中的数值会被CMAC反复使用多次，所以功耗上面肯定是合算的。不知道为何NVDLA团队没有使用这种简单的策略，毕竟用补码来做浮点的有效位不是啥新鲜事。

另外，vlibs目录下，有一些Mentor HLS工具输出的运算逻辑，看起来是把FP16转换成FP17来避开处理非规格化数的麻烦。因为FP17比FP16多一个指数位，远远包括了FP16的非规格化数。这种扩展指数位来避免非规格化数的做法，应该算是业界的一个Common Wisdom了，https://github.com/ucb-bar/berkeley-hardfloat就用了这个trick（虽然没有明说），我写的https://github.com/wangkui0508/RISCV-FPU这个半成品库中，也用了。

最后，在NVDLA中，使用了如此之多的非标准浮点运算，让人不禁深深敬佩NV的软件实力和验证功底。首先软件必须对这些非标准浮点对模型精度的影响做出评估，确认没有大的问题。其次，验证团队必须在没有标准的浮点参考模型的情况下，把这些浮点数据通路验证充分了。


